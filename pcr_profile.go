// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2019 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package secboot

import (
	"fmt"

	"github.com/chrisccoulson/go-tpm2"

	"golang.org/x/xerrors"
)

// pcrValuesList is a list of PCR value combinations computed from PCRProtectionProfile.
type pcrValuesList []tpm2.PCRValues

// setValue sets the specified PCR to the supplied value for all branches.
func (l pcrValuesList) setValue(alg tpm2.HashAlgorithmId, pcr int, value tpm2.Digest) {
	for _, v := range l {
		v.SetValue(pcr, alg, value)
	}
}

// extendValue extends the specified PCR with the supplied value for all branches.
func (l pcrValuesList) extendValue(alg tpm2.HashAlgorithmId, pcr int, value tpm2.Digest) {
	for _, v := range l {
		if _, ok := v[alg]; !ok {
			v[alg] = make(map[int]tpm2.Digest)
		}
		if _, ok := v[alg][pcr]; !ok {
			v[alg][pcr] = make(tpm2.Digest, alg.Size())
		}
		h := alg.NewHash()
		h.Write(v[alg][pcr])
		h.Write(value)
		v[alg][pcr] = h.Sum(nil)
	}
}

func (l pcrValuesList) copy() (out pcrValuesList) {
	for _, v := range l {
		ov := make(tpm2.PCRValues)
		for alg := range v {
			ov[alg] = make(map[int]tpm2.Digest)
			for pcr := range v[alg] {
				ov[alg][pcr] = v[alg][pcr]
			}
		}
		out = append(out, ov)
	}
	return
}

type pcrProfileOp int

const (
	pcrProfileOpAdd pcrProfileOp = iota
	pcrProfileOpAddFromTPM
	pcrProfileOpExtend
	pcrProfileOpOr
)

// pcrProtectionProfileInstr is a building block of PCRProtectionProfile.
type pcrProtectionProfileInstr struct {
	op   pcrProfileOp
	args []interface{}
}

// PCRProtectionProfile defines the PCR profile used to protect a key sealed with SealKeyToTPM. It contains a sequence of instructions
// for computing combinations of PCR values that a key will be protected against. The profile is built using the methods of this type.
type PCRProtectionProfile []pcrProtectionProfileInstr

// AddPCRValue adds the supplied value to this profile for the specified PCR. This action replaces any value set previously in this
// profile. As this function might cause the profile to be reallocated, it is necessary to store the result.
func (p PCRProtectionProfile) AddPCRValue(alg tpm2.HashAlgorithmId, pcr int, value tpm2.Digest) PCRProtectionProfile {
	if len(value) != alg.Size() {
		panic("invalid digest length")
	}
	return append(p, pcrProtectionProfileInstr{op: pcrProfileOpAdd, args: []interface{}{alg, pcr, value}})
}

// AddPCRValueFromTPM adds the current value of the specified PCR to this profile. This action replaces any value set previously in
// this profile. The current value is read back from the TPM when the PCR values generated by this profile are computed. As this
// function might cause the profile to be reallocated, it is necessary to store the result.
func (p PCRProtectionProfile) AddPCRValueFromTPM(alg tpm2.HashAlgorithmId, pcr int) PCRProtectionProfile {
	return append(p, pcrProtectionProfileInstr{op: pcrProfileOpAddFromTPM, args: []interface{}{alg, pcr}})
}

// ExtendPCR extends the value of the specified PCR in this profile with the supplied value. If this profile doesn't yet have a
// value for the specified PCR, an initial value of all zeroes will be added first. As this function might cause the profile to be
// reallocated, it is necessary to store the result.
func (p PCRProtectionProfile) ExtendPCR(alg tpm2.HashAlgorithmId, pcr int, value tpm2.Digest) PCRProtectionProfile {
	if len(value) != alg.Size() {
		panic("invalid digest length")
	}
	return append(p, pcrProtectionProfileInstr{op: pcrProfileOpExtend, args: []interface{}{alg, pcr, value}})
}

// AddProfileOR adds one or more sub-profiles that can be used to define PCR policies for multiple conditions. Note that each
// branch must explicitly define values for the same set of PCRs. It is not possible to generate policies where each branch
// defines values for a different set of PCRs. When computing the PCR values for this profile, the sub-profiles added by this command
// will inherit the PCR values computed by this profile. As this function might cause the profile to be reallocated, it is necessary to
// store the result.
func (p PCRProtectionProfile) AddProfileOR(profiles ...PCRProtectionProfile) PCRProtectionProfile {
	return append(p, pcrProtectionProfileInstr{op: pcrProfileOpOr, args: []interface{}{profiles}})
}

// computePCRValues computes a list of different PCR value combinations from this PCRProtectionProfile.
func (p PCRProtectionProfile) computePCRValues(tpm *tpm2.TPMContext, values pcrValuesList) (pcrValuesList, error) {
	if len(values) == 0 {
		values = append(values, make(tpm2.PCRValues))
	}

	for _, instr := range p {
		switch instr.op {
		case pcrProfileOpAdd:
			values.setValue(instr.args[0].(tpm2.HashAlgorithmId), instr.args[1].(int), instr.args[2].(tpm2.Digest))
		case pcrProfileOpAddFromTPM:
			alg := instr.args[0].(tpm2.HashAlgorithmId)
			pcr := instr.args[1].(int)
			if tpm == nil {
				return nil, fmt.Errorf("cannot read current value of PCR %d from bank %v: no TPM context", pcr, alg)
			}
			_, v, err := tpm.PCRRead(tpm2.PCRSelectionList{{Hash: alg, Select: []int{pcr}}})
			if err != nil {
				return nil, xerrors.Errorf("cannot read current value of PCR %d from bank %v: %w", pcr, alg, err)
			}
			values.setValue(alg, pcr, v[alg][pcr])
		case pcrProfileOpExtend:
			values.extendValue(instr.args[0].(tpm2.HashAlgorithmId), instr.args[1].(int), instr.args[2].(tpm2.Digest))
		case pcrProfileOpOr:
			current := values
			values = nil
			for _, p := range instr.args[0].([]PCRProtectionProfile) {
				v, err := p.computePCRValues(tpm, current.copy())
				if err != nil {
					// TODO: More context
					return nil, err
				}
				values = append(values, v...)
			}
		}
	}

	return values, nil
}
